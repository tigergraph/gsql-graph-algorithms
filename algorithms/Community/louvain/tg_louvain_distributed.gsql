CREATE DISTRIBUTED QUERY tg_louvain_distributed(SET<STRING> v_type, SET<STRING> e_type, STRING wt_attr = "weight",
    INT max_iter = 10, STRING result_attr = "cid", STRING file_path = "", BOOL print_info = FALSE) {

    /*
	Distributed version louvain community detection algorithm

	Parameters:
	v_type: vertex types to traverse
	e_type: edge types to traverse
	wt_attr: attribute name for edge weights
             use empty string is graph is unweighted
	         wt_attr type is hardcoded to FLOAT
			 INT or DOUBLE can be supported by changing all `e.getAttr(wt_attr, "FLOAT")`
             to `e.getAttr(wt_attr, "INT")` or `e.getAttr(wt_attr, "DOUBLE")`
	max_iter: maximum iteration of louvain optimization
    result_attr: attribute name to assign community id results to; use empty string to skip
    file_path: file path to write CSV output to; use empty string to skip
	print_info: print louvain execution info
	*/

    TYPEDEF TUPLE <FLOAT deltaQ, FLOAT weight, VERTEX cc> move;
    SumAccum<FLOAT> @ac; #sum of the degrees of all the vertices in community C of the vertex
    ListAccum<VERTEX> @cc; #the community center
    SumAccum<FLOAT> @weight; # total weight incident to this vertex
    SumAccum<FLOAT> @ccWeight; # total weight incident to the cc vertex
    MapAccum<VERTEX,SumAccum<FLOAT>> @A; #A[c]: sum of the edge weights for the edges in community c
    MaxAccum<move> @best_move; # highest dQ, highest -Outdegree, highest cc
    ListAccum<VERTEX> @cm;  #community member list
    SumAccum<FLOAT> @@m; # total edge weight
    SumAccum<INT> @outdegree;   # helper variable for outdegree calculation
    SumAccum<INT> @@ccChange;
    MapAccum<INT, SumAccum<INT>> @@communityMap;
    MapAccum<INT, SumAccum<INT>> @@communitySizeCount;
    FILE f(file_path);

    // initialize
    Start = {v_type};
    Start = SELECT s FROM Start:s -(e_type:e)- :t
        ACCUM
            IF wt_attr != "" THEN
                @@m += e.getAttr(wt_attr, "FLOAT")*0.5,
                s.@weight += e.getAttr(wt_attr, "FLOAT")*1.0,
                s.@ccWeight += e.getAttr(wt_attr, "FLOAT")*1.0
            ELSE
                @@m += 0.5,
                s.@weight += 1.0,
                s.@ccWeight += 1.0
            END,
            s.@outdegree += 1
        // mark @cc only for vertices with more than 1 neighbors
        // and only the marked vertices will participate in the actual louvain algorithm
        // the unmorked vertices will be resolved by the vertex following heuristic
        POST-ACCUM
            IF s.@outdegree > 1 THEN s.@cc += s END;
    IF print_info THEN
        PRINT Start.size() AS AllVertexCount;
    END;

    // special @cc update in the first iteration
    Start = SELECT t FROM Start:s -(e_type:e)- :t
        WHERE s.@outdegree > 1 AND t.@outdegree > 1
        ACCUM
            IF wt_attr != "" THEN
                t.@best_move += move(e.getAttr(wt_attr, "FLOAT")*1.0 + @@m*t.@weight * (t.@weight - s.@weight), -s.@ccWeight, s.@cc.get(0))
            ELSE
                t.@best_move += move(1.0 + @@m*t.@weight * (t.@weight - s.@weight), -s.@ccWeight, s.@cc.get(0))
            END
        POST-ACCUM
            IF getDeltaQ(t.@best_move) > 0 THEN
                IF -getWeight(t.@best_move) < t.@ccWeight THEN
                    t.@cc.clear(),
                    t.@cc += getCc(t.@best_move),
                    t.@ccWeight = -getWeight(t.@best_move),
                    @@ccChange += 1
                ELSE
                    IF -getWeight(t.@best_move) == t.@ccWeight AND getvid(t) < getvid(getCc(t.@best_move))  THEN
                        t.@cc.clear(),
                        t.@cc += getCc(t.@best_move),
                        t.@ccWeight = -getWeight(t.@best_move),
                        @@ccChange += 1
                    END
                END
            END;
    IF print_info THEN
        PRINT @@ccChange AS InitChangeCount;
    END;

    // main loop
    WHILE @@ccChange > 0 LIMIT max_iter DO
        // initialize for iteration
        @@ccChange = 0;
        Start = SELECT s FROM Start:s
            WHERE s.@outdegree > 1
            POST-ACCUM
                s.@ac = 0,
                s.@cm.clear(),
                s.@A.clear();

        Start = SELECT s FROM Start:s
            ACCUM
                FOREACH v IN s.@cc DO
                    CASE WHEN getvid(v) != -1 THEN v.@cm += s END
                END;

        Start = SELECT s FROM Start:s -(e_type:e)- :t
            WHERE t.@outdegree > 1
            ACCUM 
                IF wt_attr != "" THEN
                    s.@A += (t.@cc.get(0) -> e.getAttr(wt_attr, "FLOAT")*1.0)
                ELSE
                    s.@A += (t.@cc.get(0) -> 1.0)
                END;

        Start = SELECT s FROM Start:s
            ACCUM
                FOREACH v IN s.@cc DO
                    CASE WHEN getvid(v) != -1 THEN v.@ac += s.@weight END
                END;

        Start = SELECT s FROM Start:s
            ACCUM
                FOREACH v IN s.@cm DO
                    CASE WHEN getvid(v) != -1 THEN v.@ac = s.@ac END
                END;

        // compute @max_dQ
        Start = SELECT s FROM Start:s -(e_type:e)- :t
                WHERE t.@outdegree > 1
            ACCUM
                INT A_s = 0,
                IF s.@A.containsKey(s) THEN A_s = s.@A.get(s) END,
                s.@best_move += move(s.@A.get(t.@cc.get(0)) - A_s + 1/@@m*s.@weight*(s.@ac-t.@ac), -t.@ccWeight, t.@cc.get(0))
            POST-ACCUM
                IF getDeltaQ(s.@best_move) > 0 THEN
                    IF -getWeight(s.@best_move) < s.@ccWeight THEN   // smallest best_move weight < current weight
                        s.@cc.clear(),
                        s.@cc += getCc(s.@best_move),
                        s.@ccWeight = -getWeight(s.@best_move),
                        @@ccChange += 1
                    ELSE
                        IF -getWeight(s.@best_move) == s.@ccWeight AND getvid(s.@cc.get(0)) < getvid(getCc(s.@best_move))  THEN
                            s.@cc.clear(),
                            s.@cc += getCc(s.@best_move),
                            s.@ccWeight = -getWeight(s.@best_move),
                            @@ccChange += 1
                        END
                    END
                END;
        IF print_info THEN
            PRINT @@ccChange AS IterChangeCount;
        END;
    END;

    // process node with outdegree=1
    // follow the vertex to its neighbor's community
    // if the neighbor also have outdegree=1, mark the two vertices as one community
    Start = {v_type};
    Start = SELECT s FROM Start:s -(e_type:e)- :t
        WHERE s.@outdegree == 1 AND t.@outdegree != 1
        ACCUM s.@cc += t.@cc.get(0);
    IF print_info THEN
        PRINT Start.size() AS VertexFollowedToCommunity;
    END;

    Start = {v_type};
    Start = SELECT s FROM Start:s -(e_type:e)- :t
        WHERE s.@outdegree == 1 AND t.@outdegree == 1
        ACCUM
            IF getvid(s) <= getvid(t) THEN
                s.@cc += s
            ELSE
                s.@cc += t
            END;
    IF print_info THEN
        PRINT Start.size() AS VertexFollowedToVertex;
    END;

    // save result
    Start = {v_type};
    Start = SELECT s FROM Start:s
        POST-ACCUM
            IF result_attr != "" THEN s.setAttr(result_attr, getvid(s.@cc.get(0))) END,
            IF file_path != "" THEN f.println(s, getvid(s.@cc.get(0))) END;

    // print result satistic
    IF print_info THEN
        Start = SELECT s FROM Start:s
            WHERE s.@cc.size() > 0
            POST-ACCUM
                @@communityMap += (getvid(s.@cc.get(0)) -> 1);
        PRINT @@communityMap.size() AS FinalCommunityCount;
    END;
END;
}
