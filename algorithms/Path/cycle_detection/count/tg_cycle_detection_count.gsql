CREATE QUERY tg_cycle_detection_count(SET<STRING> v_type, SET<STRING> e_type, INT depth, INT batches, BOOL print_results = TRUE)  SYNTAX V1 {


    /*
    First Author: <First Author Name>
    First Commit Date:  <First Commit Date>

    Recent Author: <Recent Commit Author Name>
    Recent Commit Date: <Recent Commit Date>


    Repository:
        https://github.com/tigergraph/gsql-graph-algorithms/tree/master/algorithms/Path

    Maturity:
        production

    Description: 
        Rochaâ€“Thatte cycle detection algorithm + fixes
        This is a distributed algorithm for detecting all the cycles on large-scale directed graphs.In every iteration, the vertices send its sequences to its out-neighbors, and receive the sequences from the in-neighbors.
        Stop passing the sequence (v1,v2,v3, ...) when:
            1. v = v1. If v has the minimum label in the sequence, report the cycle
            2. v = vi (i!=1). Do not report since this cycle is already reported in an earlier iteration

        Added a cull so we only count a cycle once by only counting a cycle if it starts from the lowest vid in that cycle.
        This allows for early exit in loop so should save memory too.
        Self cycles treated completely separately to save memory and increase speed

    Publications:
        <link>

    TigerGraph Documentation:
        <link>

    Parameters:
        v_type:
            Names of vertex types to use
        e_type:
            Names of edge types to use
        depth:
            Maximum cycle length to search for, equal to the maximum number of iterations
        batches:
            Number of batches to partition by
        print_results:
            If True, output JSON to standard output
    */
  
ListAccum<ListAccum<UINT>> @curr_list, @new_list; //, @@out_cycles;
SumAccum<INT> @@sum_cycles=0;
INT loop_depth ;
loop_depth = depth-1; // as we are performing the first step outside the loop

// Do first iteration, ignore self loops (can add in later)
// assuming cull where cycle not started at lowest id, so any one cycle only counted once
  
FOREACH batch_number IN RANGE[0,batches-1] DO  
    Active = {v_type};
    Active = SELECT vv 
             FROM Active:vv
             POST-ACCUM vv.@curr_list.clear()
             HAVING getvid(vv)%batches==batch_number;
    
    IF depth > 0 THEN
        Active = SELECT t 
                 FROM Active:s -(e_type)- v_type:t
                 WHERE getvid(s) < getvid(t)   // so cannot be self-join, and asserts s must be lowest
                 ACCUM 
                     t.@curr_list += [getvid(s)] // lists of precedents
                 HAVING t.@curr_list.size() > 0;  # IF receive no sequences, deactivate it;
    END;
    WHILE Active.size() > 0 LIMIT loop_depth DO 
        Active = SELECT t 
                 FROM Active:s -(e_type:e)- v_type:t
                 WHERE s != t
                 ACCUM 
                     INT t_id = 0,
                     t_id = getvid(t),
                     FOREACH sequence IN s.@curr_list DO
                         IF t_id < sequence.get(0) THEN // early exit, sequence started from wrong place so cull
                             CONTINUE 
                         ELSE IF t_id == sequence.get(0) THEN  # cycle detected
                             @@sum_cycles += 1
                         ELSE IF sequence.contains(t_id) == FALSE THEN   # discard the sequences contain t
                             t.@new_list += sequence + [getvid(s)]   # store sequences in @newList to avoid confliction  with @currList
                         END
                     END
                 POST-ACCUM s.@curr_list.clear();
      Active = SELECT t FROM Active:t    
              POST-ACCUM t.@curr_list = t.@new_list,
                         t.@new_list.clear()
              HAVING t.@curr_list.size() > 0;   # IF receive no sequences, deactivate it;
    END;
  
END;
  
// Self loops here
all = {v_type};
selfy = SELECT vv 
        FROM all:vv-(e_type)-v_type:tt
        WHERE vv==tt; 
@@sum_cycles+=selfy.size();

IF print_results THEN
    PRINT @@sum_cycles AS cycles;
END;  
}
